# MyBookSystem
最后提交


首先讲数据库，在本系统中使用的是mysql数据库，在进行批量操作时希望开启事务管理，当出错时回滚，但发现数据库并没有回滚。查资料发现mysql默认的数据库引擎是MyISAM，而这个引擎不支持事务，需要换成InnoDB。两者的差别是MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。所以为了后面的方便，我把所有表的引擎都换成了InnoDB.

上面讲了数据库引擎，下面来谈一下关于主键的问题，开始我所有的表的主键都是自增主键，后来听了老师的建议全部换成了随机主键，在每次插入时都调用UUID这个函数生成一个随机主键，在mybatis中使用selectlkey来获取这个新增主键。虽然这种主键生成策略的确可行，但是我觉得由于在数据库中仍然需要标明位数限制，与自增主键规定同样的位数没有本质的区别，只是可能系统的使用年限的问题。

然后是关于sqlmode的一些东西。我发现在单独使用groupby时，数据库不会报异常，但是如果把groupBy这条语句作为子查询放在另一段语句间就会报异常，而异常的原因就是当前的sqlmode不支持FullGroupBy,这是一个很棘手的问题。在网上找到了一些修改sqlmode的方法，但是都只在本次运行有效，当重启了mysql,或开关机后sqlmode会恢复成原来的样子，这显然不是解决问题的最佳办法。后来我调整了sql,让数据库只执行一些简单的，转而在代码里完成数据分组。即在service层完成这些，数据库只做简单的查询，这样就不会业务下沉了。

然后再谈最靠近数据库的持久层，这里我使用了mybatis,起初是觉得，对于本系统而言首要解决的就是各个实体间的复杂的关系，只有捋顺了这些关系才可能得到最终想要的结果，mybatis可以简单的利用sql和一些mapper接口就可以实现。而在mybatis中这些关联关系并不能像在hebernate中那样在类中定义好了就一次解决了，只有在sql语句中这种关系才会显现。所以mybatis的确可以比较灵活的处理一些关联关系，降低业务处理的难度但是也会使层次化的设计结构更加不清晰，而且它一旦承担一些业务上的功能就意味着数据库要承受更大压力。所以在框架的选取上，要依情况而定。

关于springboot,这真的是一个非常方便的工具，只要在pom.xml中配置好工程的所有的依赖，它就会帮你加载所有的jar。然后再谈springmvc,这个框架也非常强大，它可以接收各种类型的前台数据。

如果前台请求的是json串（即指定contentType=application/json）这时只需要用个@RequestBody就可以将json串转换成java对象了，然后如果整个方法加个@ResponseBody就可以将后台得到的java对象转成json串输出了；如果请求的不是json串（即指定contentType=application/x-www-form-urlen）接收的时候就不需要@ResponseBody了，它可以直接传然后转成java对象。使用springmvc的时候完全不用管json数据和java对象的转换问题，这些框架会自动帮我们完成。这是单单传数据的情况，有时候我们希望数据传递和页面跳转能同时进行，这时候我们可以返回一个ModelAndView,通过ModelAndView.addObject（key,value）的方式给它带上数据。

然后我们谈谈负责后台进行数据交互的部分。和后台的数据交互无非分两种，一种是主动向后台请求，一种是被动接受。

先谈主动请求，这是最常见的一种，多数时候提交一个表单，或者通过一个a标签直接跳转或者发个异步请求。在本次开发中多半使用了异步请求，因为多数情况不需要页面跳转而是页面局部刷新。主要使用了ajax和axios这两个，axios是比ajax更轻量级的工具。在向后台传一个数组时，用ajax的post方法向后台传数据完全可以，等到了axios就遇到了困难，要么传不过去要么传过去的是object但后台收到[]的，后来通过观察他们的区别发现是contentType这里的问题，然后重新封装了参数用axios的post方式成功的发过去了。

然后讲数据的被动接受，在jsp页面这是很容易实现的事情，用个el表达式就可以了，但是springboot官网不推荐使用jsp,所以就使用了Thymeleaf，Thymeleaf是个XML/XHTML/HTML5模板引擎，可以用于Web与非Web应用。像下面这样就能在html页面里把product.availableFrom的值取出来了



<dd th:text="${product.availableFrom}">2014-12-01</dd>



完全可以达到和在jsp页面使用el一样的效果。

然后再讲一个复杂一点的问题，就是在打印采购单时，想先判断用户选择的条数如果为0自然不进行打印。这个过程既需要数据预处理，预处理完还要把数据发给后台进行处理后台处理完要返回一个带数据的页面，起初不管是用axios还是ajax都能成功的预处理完然后数据也能成功传到后台，但是在返回时，由于返回了modelAndView,在前台可以请求成功得到相应页面的html但是跳转的页面并不显示出来，而且也没有走axios或ajax成功的方法，这是很奇怪的问题，后来我还尝试用form来发这样当前请求页面就不会去拦截响应了，但是用form发的请求都是key-value的形式，不改content_type

后台根本接收不到，所以这次尝试失败，还是想办法发异步请求，然后请教了别人后才知道，是发异步请求的时候那个datatype=”json”不能乱写，写了这个就意味着返回的必须是json数据，类型不符的话也就不会走成功的方法了，然后我去掉了这个果然成功的方法就执行了。然后在这个成功的方法里我拿到了新页面的html代码，该加的数据已经插进去了，下一步就是跳出整个iframe,把html代码变成页面展示出来，这里我就用了段原生的js: top.document.write(jsonResult);top.document.close();有时候原生js还是很好用的，至此整个问题都解决了。      然后谈谈vue,用这个和传统的jquery比起来方便多了，在vue中不在是直接操作dom.之所以我们会去操作dom是因为我们的数据有变，所以vue就提出直接操作数据，控制权直接给数据。我们可以通过简单的v指令就绑定数据和dom。像v-model它可以通过用户活动改变data,或者代码里的改变直接改变data,这种双向的绑定关系有时候实在太方便了。还有v-bind指令，它可以绑定某个标签的属性，这很神奇，也是vue灵活的原因。谈到data就不得不谈vue的computed和watch了，这两个都有对数据的监听功能，computed是计算属性，代码段里面的数据有变化就会触发计算出一个新的数据来，而watch监听的是data里面的数据，如果数据有变化执行一系列动作。当有耗时的操作时比如异步加载放在watch里面更合适。在data里面的数据都是vue初始化的时候注册的，所以如果想给某个数据添加可以被监听到的属性时就需要使用vue.set了，这个可以注册一个data里面没有的属性。像在实现全选和取消全选时就是通过给每个对象注册一个CHECKED属性实现的。      以上便是本次开发过程的一些总结，困难很多，但收获良多。 
